<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Web Share Target API
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"
    defer></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial", // until we publish a FPWD!
        github: {
          repoURL: "w3c/web-share-target",
          branch: "main"
        },
        group: "webapps",
        editors: [{
          name: "Matt Giuca",
          company: "Google Inc.",
          companyURL: "https://google.com",
          w3cid: 91260
        },
        {
          name: "Eric Willigers",
          company: "Google Inc.",
          companyURL: "https://google.com",
          w3cid: 67534
        }],
        // eventually add mdn: true, and caniuse: "web-share-target"
        xref: "web-platform",
      };
    </script>
  </head>
  <body data-cite="Web-Share encoding">
    <section id="abstract">
      <p>
        This specification defines an API that allows websites to declare
        themselves as <a>web share targets</a>, which can receive shared
        content from either the [[[Web-Share]]], or system events (e.g., shares
        from native apps).
      </p>
      <p>
        This is a similar mechanism to
        {{NavigatorContentUtils/registerProtocolHandler()}}, in that it works
        by registering the website with the user agent, to later be
        <a>invoked</a> from another site or native application via the user
        agent (possibly at the discretion of the user). The difference is that
        {{NavigatorContentUtils/registerProtocolHandler()}} registers the
        handler via a programmatic API, whereas a Web Share Target is declared
        in the [[[appmanifest]]], to be registered at a time of the user agent
        or user's choosing.
      </p>
    </section>
    <section id="sotd">
      <p>
        This is an early draft of the Web Share Target spec.
      </p>
    </section>
    <section>
      <h2>
        Prerequisites
      </h2>
      <p>
        In order to implement this API, a the user agent MUST support
        [[[appmanifest]]]. This spec also re-uses some definitions from the
        [[[Web-Share]]] spec. However, support for the [[[Web-Share]]] is
        OPTIONAL.
      </p>
    </section>
    <section class="informative" data-link-for="WebAppManifest">
      <h2>
        Usage Example
      </h2>
      <p>
        To register a site as a share target, a <a>share_target</a> entry is
        added to the [[[appmanifest]]], as shown:
      </p>
      <pre class="example json" title="manifest.webmanifest">
      {
        "name": "Includinator",
        "share_target": {
          "action": "share.html",
          "params": {
            "title": "name",
            "text": "description",
            "url": "link"
          }
        }
      }
      </pre>
      <p>
        The {{ShareTarget/params}} keys correspond to the key names in
        {{ShareData}} from [[Web-Share]], while the values are arbitrary names
        that will be used as query parameters when the target is launched.
      </p>
      <p>
        When a share takes place, if the user selects this share target, the
        user agent opens a new browsing context at the `action` URL, with query
        parameter values containing the shared data, just like an HTML form
        submission.
      </p>
      <p>
        For the purpose of this example, we assume the manifest is located at
        `https://example.org/includinator/manifest.webmanifest`.
      </p>
      <pre class="example html" title="share.html">
      &lt;html&gt;
        &lt;head&gt;
          &lt;link rel="manifest" href="manifest.webmanifest"&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;script&gt;
            window.addEventListener('load', () =&gt; {
              const parsedUrl = new URL(window.location);
              const { searchParams } = parsedUrl;
              console.log("Title shared:", searchParams.get('name'));
              console.log("Text shared:", searchParams.get('description'));
              console.log("URL shared:", searchParams.get('link'));
            });
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
      </pre>
      <p>
        If an incoming share contains the title "My News" and the URL
        <code>http://example.com/news</code>, the user agent will open a new
        window or tab and navigate to:
      </p>
      <pre>
https://example.org/includinator/share.html?name=My+News&amp;link=http%3A%2F%2Fexample.com%2Fnews
</pre>
      <p class="warning">
        U+0020 (SPACE) characters are encoded as "`+`", due to the use of
        <a data-cite="url">application/x-www-form-urlencoded</a> encoding, not
        "`%20`" as might be expected. Processors must take care to decode
        U+002B (+) characters as U+0020 (SPACE), which some URL decoding
        libraries, including ECMAScript's <a data-cite=
        "ECMASCRIPT#sec-decodeuricomponent-encodeduricomponent">`decodeURIComponent`</a>
        function, may not do automatically.
      </p>
      <p>
        The query parameters are populated with information from the
        {{ShareData}} being shared. If the ShareData contains no information
        for a given member, the query parameter is omitted.
      </p>
      <p>
        A share target might only be interested in a subset of the
        {{ShareData}} members. This example also shows a share target that
        receives data as a `POST` request, which should be the case if the
        request causes an immediate side effect.
      </p>
      <pre class="example json" title="manifest.webmanifest">
      {
        "name": "Bookmark",
        "share_target": {
          "action": "/bookmark",
          "method": "POST",
          "enctype": "multipart/form-data",
          "params": {
            "url": "link"
          }
        }
      }
      </pre>
      <p>
        The shared information might be read by a <a data-cite=
        "service-workers-1#service-worker-concept">service worker</a>, rather
        than being sent over the network to the server.
      </p>
      <pre class="example javascript" title="sw.js">
      self.addEventListener('fetch', event =&gt; {
        if (event.request.method !== 'POST') {
          event.respondWith(fetch(event.request));
          return;
        }

        event.respondWith((async () =&gt; {
          const formData = await event.request.formData();
          const link = formData.get('link') || '';
          saveBookmark(link);
          return new Response('Bookmark saved: ' + link);
        })());
      });
      </pre>
      <p>
        How the handler deals with the shared data is at the handler's
        discretion, and will generally depend on the type of app. Here are some
        suggestions:
      </p>
      <ul>
        <li>An email client might draft a new email, using <code>title</code>
        as the subject of an email, with <code>text</code> and <code>url</code>
        concatenated together as the body.
        </li>
        <li>A social networking app might draft a new post, ignoring
        <code>title</code>, using <code>text</code> as the body of the message
        and adding <code>url</code> as a link. If <code>text</code> is missing,
        it might use <code>url</code> in the body as well. If <code>url</code>
        is missing, it might scan <code>text</code> looking for a URL and add
        that as a link.
        </li>
        <li>A text messaging app might draft a new message, ignoring
        <code>title</code> and using <code>text</code> and <code>url</code>
        concatenated together. It might truncate the text or replace
        <code>url</code> with a short link to fit into the message size.
        </li>
      </ul>
    </section>
    <section data-link-for="WebAppManifest">
      <h2>
        Extension to the Web App Manifest
      </h2>
      <p>
        The following IDL extends the <dfn data-cite=
        "!appmanifest#dom-webappmanifest">WebAppManifest</dfn> dictionary.
      </p>
      <pre class="idl">
      dictionary ShareTargetParams {
        USVString title;
        USVString text;
        USVString url;
      };

      dictionary ShareTarget {
        required USVString action;
        DOMString method = "GET";
        DOMString enctype = "application/x-www-form-urlencoded";
        required ShareTargetParams params;
      };

      partial dictionary WebAppManifest {
        ShareTarget share_target;
      };
      </pre>
      <p>
        The following steps are added to the <a data-cite=
        "!appmanifest#dfn-extension-point">extension point</a> in the steps for
        <a data-cite="appmanifest#dfn-processing-a-manifest">processing a
        manifest</a>:
      </p>
      <ol>
        <li>Set <var>manifest</var>["<a>share_target</a>"] to the result of
        running <a>post-processing the <code>share_target</code> member</a>
        given <var>manifest</var>["<a>share_target</a>"],
        <var>manifest</var>["<a data-cite=
        "!appmanifest#dom-webappmanifest-scope"><code>scope</code></a>"], and
        <var>manifest URL</var>.
        </li>
      </ol>
      <section data-dfn-for="WebAppManifest">
        <h3>
          <code>share_target</code> member
        </h3>
        <p>
          The <dfn>share_target</dfn> member of the manifest is a
          <a>ShareTarget</a> dictionary that declares this application to be a
          <a>web share target</a>, and describes how the application receives
          share data.
        </p>
        <p>
          A <dfn data-lt="web share targets">web share target</dfn> is a web
          site with a valid manifest containing a <a>share_target</a> member. A
          web share target is a type of <a>share target</a>.
        </p>
        <p>
          The steps for <dfn>post-processing the <code>share_target</code>
          member</dfn> is given by the following algorithm. The algorithm takes
          a <a>ShareTarget</a> <var>share target</var>, a <a>URL</a> <var>scope
          URL</var>, and a <a>URL</a> <var>manifest URL</var>. This algorithm
          returns a <a>ShareTarget</a> or <code>undefined</code>.
        </p>
        <ol>
          <li>If <var>share target</var> is <code>undefined</code>, then return
          <code>undefined</code>.
          </li>
          <li>If <var>share target</var>["<a data-link-for=
          "ShareTarget">method</a>"] is neither an <a data-cite=
          "!INFRA#ascii-case-insensitive">ASCII case-insensitive</a> match for
          the strings <code>"GET"</code> nor <code>"POST"</code>,
            <a data-cite="appmanifest#dfn-issue-a-developer-warning">issue a
            developer warning</a> that the method is not supported, and return
            <code>undefined</code>.
          </li>
          <li>If <var>share target</var>["<a data-link-for=
          "ShareTarget">method</a>"] is an <a data-cite=
          "!INFRA#ascii-case-insensitive">ASCII case-insensitive</a> match for
          the string <code>"POST"</code> and <var>share
          target</var>["<a data-link-for="ShareTarget">enctype</a>"] is neither
          an <a data-cite="INFRA#ascii-case-insensitive">ASCII
          case-insensitive</a> match for the strings
          <code>"application/x-www-form-urlencoded"</code> nor
          <code>"multipart/form-data"</code>, <a data-cite=
          "!appmanifest#dfn-issue-a-developer-warning">issue a developer
          warning</a> that the enctype is not supported, and return
          <code>undefined</code>.
          </li>
          <li>Let <var>action</var> be the result of <a data-cite=
          "!URL#concept-url-parser">parsing</a> the <a>URL</a> <var>share
          target</var>["<a data-link-for="ShareTarget">action</a>"], relative
          to the <var>manifest URL</var> and with no encoding override. If the
          result is failure, <a data-cite=
          "!appmanifest#dfn-issue-a-developer-warning">issue a developer
          warning</a> and return <code>undefined</code>.
          </li>
          <li>If <var>action</var> is not <a data-cite=
          "!appmanifest#dfn-within-scope">within scope</a> of <var>scope
          URL</var>, <a data-cite="appmanifest#dfn-issue-a-developer-warning">
            issue a developer warning</a> that <a data-link-for=
            "ShareTarget">action</a> is outside of the <a data-cite=
            "!appmanifest#dfn-navigation-scope">navigation scope</a> , and
            return <code>undefined</code>.
          </li>
          <li>If the <a data-cite="URL#concept-url-origin">origin</a> of <var>
            action</var> is not <a data-cite=
            "!SECURE-CONTEXTS/#is-origin-trustworthy">potentially
            trustworthy</a>, <a data-cite=
            "!appmanifest#dfn-issue-a-developer-warning">issue a developer
            warning</a> and return <code>undefined</code>.
          </li>
          <li>Set <var>share target</var>["<a data-link-for=
          "ShareTarget">action</a>"] to <var>action</var>.
          </li>
          <li>Return <var>share target</var>.
          </li>
        </ol>
      </section>
      <section data-dfn-for="ShareTarget" data-link-for="ShareTarget">
        <h3>
          <code>ShareTarget</code> and its members
        </h3>
        <p>
          The <dfn>ShareTarget</dfn> dictionary contains the following members.
        </p>
        <p>
          The <dfn>action</dfn> member specifies the <a>URL</a> for the
          <a data-link-for="web share targets">web share target</a>.
        </p>
        <p>
          The <dfn>method</dfn> member specifies the HTTP request <a href=
          "https://tools.ietf.org/html/rfc7231#section-4">method</a> for the
          <a data-link-for="web share targets">web share target</a>.
        </p>
        <p class="note">
          A use case for <code>GET</code> requests is when the share target
          drafts a message for subsequent user approval. If the share target
          performs a side-effect without any user interaction, `POST` requests
          should be used.
        </p>
        <p>
          The <dfn>enctype</dfn> member specifies how the share data is encoded
          in the body of a `POST` request. It is ignored when <a>method</a> is
          <code>"GET"</code>.
        </p>
        <p>
          The <dfn>params</dfn> member contains a <a>ShareTargetParams</a>
          dictionary.
        </p>
      </section>
      <section data-dfn-for="ShareTargetParams" data-link-for=
      "ShareTargetParams">
        <h3>
          <code>ShareTargetParams</code> and its members
        </h3>
        <p>
          The <dfn>ShareTargetParams</dfn> dictionary contains the following
          members.
        </p>
        <p>
          The <dfn>title</dfn> member specifies the name of the query parameter
          used for the title of the document being shared.
        </p>
        <p>
          The <dfn>text</dfn> member specifies the name of the query parameter
          used for the arbitrary text that forms the body of the message being
          shared.
        </p>
        <p>
          The <dfn>url</dfn> member specifies the name of the query parameter
          used for the URL string referring to a resource being shared.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Registration of web share targets
      </h2>
      <p>
        How and when <a>web share targets</a> are "registered" is at the
        discretion of the user agent and/or the end user. In fact,
        "registration" is a user-agent-specific concept that is not formally
        defined here; user agents are NOT REQUIRED to "register" web share
        targets at all; they are only REQUIRED to provide some mechanism to
        convey shared data to a web share target of the end user's choosing.
        User agents MAY consider a web share target "registered" even if it is
        not <a data-cite="appmanifest#dfn-install">installed</a>.
      </p>
      <p>
        The user agent MAY automatically register all <a>web share targets</a>
        as the user visits the site, but it is RECOMMENDED that more discretion
        is applied, to avoid overwhelming the user with the choice of a large
        number of targets.
      </p>
      <div class="note">
        <p>
          Examples of registration strategies that user agents can employ are:
        </p>
        <ul>
          <li>Only register a web share target once it is <a data-cite=
          "appmanifest#dfn-install">installed</a>.
          </li>
          <li>Only register a web share target once the end user has used the
          site for some period of time.
          </li>
          <li>Explicitly prompt the user to register a web share target
          (perhaps using the same UI as
          {{NavigatorContentUtils/registerProtocolHandler()}}).
          </li>
          <li>Only register a web share target if it has a service worker.
          </li>
        </ul>
      </div>
      <p>
        When presenting the end user with a list of <a>web share targets</a>,
        the user agent MAY use an online service which has pre-indexed
        manifests, and therefore show the user targets that they have never
        visited or explicitly registered.
      </p>
      <div class="issue" data-number="26"></div>
    </section>
    <section>
      <h2>
        Handling incoming shares
      </h2>
      <p>
        A <a>web share target</a> is <dfn data-lt=
        "invoke|invocation">invoked</dfn> when the end user is sharing some
        data intended for a generic application, and indicates that specific
        web share target as the receiver of the data.
      </p>
      <p>
        It is not specified where the data comes from, or how the end user
        indicates the web share target as the receiver. However, one possible
        source is a call to {{Navigator}}'s {{Navigator/share()}} method in the
        same user agent.
      </p>
      <div class="note">
        <p>
          Examples of other possible sources of a <a>web share target</a>
          invocation are:
        </p>
        <ul>
          <li>From the built-in UI of the user agent (<i>e.g.</i>, the end user
          picks "Share" from a browser's menu, to share the current page title
          as "<code>title</code>" and the current page URL as
          "<code>url</code>").
          </li>
          <li>A share action triggered from a native application (via a
          proprietary share system), followed by the end user choosing a web
          share target as the receiver.
          </li>
        </ul>
      </div>
      <section>
        <h3>
          Obtaining a <code>ShareData</code>
        </h3>
        <p>
          When a <a>web share target</a> is <a>invoked</a>, the data MAY be in
          an unspecified format. The user agent MUST first convert the data
          into a {{ShareData}} dictionary, if it is not already, by mapping to
          the fields of <code>ShareData</code> from equivalent concepts in the
          host system. If the source was a call to {{Navigator/share()}}, the
          user agent SHOULD use the {{ShareData}} argument unmodified (but this
          is not always possible, as it might have to round-trip through some
          other format in a lossy manner). The user agent MAY employ heuristics
          to map the data onto the <code>ShareData</code> fields as well as
          possible.
        </p>
        <p class="note">
          For example, the host share system may not have a dedicated URL
          field, but a convention that both plain text and URLs are sometimes
          transmitted in a "text" field. This is the case on Android. The user
          agent can check whether all or part of the "text" field is a [=valid
          URL string=], and if so, move that part of the "text" field to the
          {{ShareData}}'s {{ShareData/url}} member.
        </p>
      </section>
      <section data-link-for="WebAppManifest">
        <h3>
          Launching the web share target
        </h3>
        <p>
          When <a>web share target</a> having <a>WebAppManifest</a>
          <var>manifest</var> is <a>invoked</a> with {{ShareData}}
          <var>data</var>, run the following steps:
        </p>
        <ol>
          <li>Let <var>url</var> be a copy of
          <var>manifest</var>["<a>share_target</a>"]["<a data-link-for=
          "ShareTarget">action</a>"].
          </li>
          <li>Let <var>entry list</var> be a new empty list of name-value
          tuples.
          </li>
          <li>For each <var>member</var> in the sequence «
          <code>"title"</code>, <code>"text"</code>, <code>"url"</code> »,
            <ol>
              <li>Let <var>name</var> be the value of
              <var>manifest</var>["<a>share_target</a>"]["<a data-link-for=
              "ShareTarget">params</a>"][<var>member</var>].
              </li>
              <li>If <var>name</var> is <code>undefined</code> or an empty
              string, then continue.
              </li>
              <li>Let <var>value</var> be the value of
              <var>data</var>[<var>member</var>].
              </li>
              <li>If <var>value</var> is <code>undefined</code>, then continue.
              </li>
              <li>
                <a data-cite="INFRA#list-append">Append</a> to <var>entry
                list</var> a tuple with <var>name</var> and <var>value</var>.
              </li>
            </ol>
          </li>
          <li>Let <var>header list</var> be a new empty <a data-cite=
          "!FETCH/#concept-header-list">header list</a>.
          </li>
          <li>Let <var>method</var> be
          <var>manifest</var>["<a>share_target</a>"]["<a data-link-for=
          "ShareTarget">method</a>"].
          </li>
          <li>Let <var>enctype</var> be
          <var>manifest</var>["<a>share_target</a>"]["<a data-link-for=
          "ShareTarget">enctype</a>"].
          </li>
          <li>If <var>method</var> is <code>"GET"</code>:
            <ol>
              <li>Let <var>query</var> be the result of running the
              [=urlencoded serializer=] with <var>entry list</var> and no
              encoding override.
              </li>
              <li>Set <var>url</var>'s <a data-cite=
              "!URL#concept-url-query">query</a> component to <var>query</var>.
              </li>
              <li>Let <var>body</var> be null.
              </li>
            </ol>
          </li>
          <li>Otherwise, if <var>method</var> is <code>"POST"</code> and <var>
            enctype</var> is <code>"application/x-www-form-urlencoded"</code>:
            <ol>
              <li>Let <var>body</var> be the result of running the [=urlencoded
              serializer=] with <var>entry list</var> and no encoding override.
              </li>
              <li>Set <var>body</var> to the result of [=UTF-8 encode=]
              <var>body</var>.
              </li>
              <li>[=header list/Append=]
              <code>"Content-Type"</code>/<code>"application/x-www-form-urlencoded"</code>
              to <var>header list</var>.
              </li>
            </ol>
          </li>
          <li>Otherwise, if <var>method</var> is <code>"POST"</code> and <var>
            enctype</var> is <code>"multipart/form-data"</code>:
            <ol>
              <li>Let <var>body</var> be the result of running the
              <a>multipart/form-data encoding algorithm</a> with <var>entry
              list</var> and the [=UTF-8=] encoding.
              </li>
              <li>Let <var>MIME type</var> be the concatenation of the string
              <code>"multipart/form-data;"</code>, a U+0020 SPACE character,
              the string <code>"boundary="</code>, and the <a data-cite=
              "!HTML#multipart/form-data-boundary-string"><code>multipart/form-data</code>
              boundary string</a> generated by the <a data-cite=
              "!HTML#multipart/form-data-encoding-algorithm"><code>multipart/form-data</code>
              encoding algorithm</a>.
              </li>
              <li>[=header list/Append=] <code>"Content-Type"</code>/<var>MIME
              type</var> to <var>header list</var>.
              </li>
            </ol>
          </li>
          <li>Let <var>browsing context</var> be the result of creating a
          <a data-cite="HTML#creating-a-new-browsing-context">new</a>
          <a data-cite="HTML#top-level-browsing-context">top-level browsing
          context</a>.
          </li>
          <li>
            <a data-cite="HTML#navigate">Navigate</a> <var>browsing
            context</var> to a new <a data-cite=
            "!FETCH/#concept-request">Request</a> whose method is
            <var>method</var>, url is <var>url</var>, header list is
            <var>header list</var>, and body is <var>body</var>.
          </li>
        </ol>
        <p class="note">
          This algorithm assumes that <var>manifest</var> has had the
          <a>post-processing the <code>share_target</code> member</a> algorithm
          run on it and still has a <a>share_target</a> afterwards.
        </p>
      </section>
    </section>
    <section class="informative" data-cite="secure-contexts">
      <h2>
        Accessibility
      </h2>
      <p>
        This specification has no known accessibility considerations.
      </p>
    </section>
    <section class="informative" data-cite="secure-contexts">
      <h2>
        Security and privacy considerations
      </h2>
      <ul>
        <li>Invoking a <a>web share target</a> means potentially sending
        private user data to a third-party website. Implementors are to take
        every precaution that the user understands which party the data is
        being sent to (<i>e.g.</i>, communicating the web share target's
        origin), before running the <a>invocation</a> algorithm.
        </li>
        <li>Of particular concern is spoofing: a web share target presenting
        itself as a different party (by setting its name and icon accordingly).
        </li>
        <li>The spoofing risk is heightened if web share targets are chosen
        from an online index, rather than a set of targets that the end user
        has explicitly installed or registered.
        </li>
        <li>The requirement that the web share target's origin be a
        [=potentially trustworthy origin=] is to prevent private user data from
        being transmitted to a party that does not control the origin in
        question, or in clear text over the network.
        </li>
        <li>A source site using Web Share API, and a receipient site using Web
        Share Target, could cooperate to join user ids. The source site could
        use `navigator.share(text: my_id_for_this_user)`, and the (user-chosen)
        recipient could use that information to join its own user ID with the
        source origin's user ID. Both sides of the transfer would need to write
        code to accomplish the transfer, and the user would need to pick the
        recipient.
        </li>
      </ul>
    </section>
    <section id="conformance"></section>
    <section class="appendix informative">
      <h2>
        Acknowledgments
      </h2>
      <p>
        Thanks to the [[[WEBINTENTS]]] team, who laid the groundwork for the
        web app interoperability use cases. In particular, <a href=
        "https://paul.kinlan.me/">Paul Kinlan</a>, who did a lot of early
        advocacy for Web Share and Web Share Target.
      </p>
      <p>
        Thanks to Connie Pyromallis, who wrote an early draft of this spec, and
        helped design and prototype the API.
      </p>
      <p>
        Thanks to Alex Russell and David Baron, for their feedback on early
        drafts of this spec.
      </p>
    </section>
  </body>
</html>
